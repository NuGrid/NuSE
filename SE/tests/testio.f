C     *******************************************************************
C     ********************* TESTIO.F/COOKBOOK ***************************
C     *******************************************************************
C     This file contains the official test suite that makes up 9 data
C     sets, writes them into test.h5 as individual data sets with some
C     attributes attached. Then, we read the data back out and save them
C     again in test2.h5. Afterwards, we can then compare test.h5 and
C     test2.h5 that they are identical. Use this file as a template on
C     how to use the SE library in Fortran. It should contain all the
C     basic functionality that you need.
C

      IMPLICIT NONE
      integer MSL, NSP
C     "MSL" is the maximum number of shells that you may read
C     in/create. It must be greater or equal to the actual number of
C     shells of course. "NSP" on the other hand is the number of
C     isotopes. Note that right now, the code saves the first 7
C     isotopes. This number is currently hardwired to the code, but
C     easily adjustable by us. We will make this more flexible in a
C     future release.
      parameter (MSL=1553, NSP=49)
      integer nstart, nend
      integer MODELL, M, I, J
      DOUBLE PRECISION MASS(MSL), R(MSL), RHO(MSL), TEMP(MSL), PR(MSL),
     $     V(MSL), DCOEFF(MSL), YPS(MSL,NSP), MTOT
      DOUBLE PRECISION MASS2(MSL), R2(MSL), RHO2(MSL), TEMP2(MSL), 
     $     PR2(MSL), V2(MSL), DCOEFF2(MSL), YPS2(MSL,NSP), MTOT2
      CHARACTER*7 FILENAME
      parameter (FILENAME="test.h5")
      CHARACTER*8 FILENAME2
      parameter (FILENAME2="test2.h5")
      CHARACTER*8 VERSION2
      INTEGER FID1, FID2
C
C     Let's say our particular number of shells in our data set is
C     1550. This can in principle be different for each model (cycle)
C     that you want to save, even if they are saved in the same hdf5
C     file
      M = 1550
C     Let's say we want to save cycles 31001 to 31009
      nstart = 31001
      nend = 31009
C

C     Open the file "FILENAME" and save the file id into "FID1". You
C     have to pass the length of the array, since FILENAME is only a
C     pointer in the C function that you are calling
      call FSE_OPEN(FILENAME, FID1)

C     Write a global attribute to the file, i.e. an attribute that
C     belongs to the full run, not an individual data set. The second
C     argument has to be set to "-1" to write a global attribute. If it
C     is a positive number "i", it will be attached to dataset "i"
C     instead. The "S" in the function call ("S"ATTR) simply says that
C     you are passing a string. A "D" stands for double, "F" for float,
C     "I" for integer. However, they don't need the length argument at
C     the end (see the examples below).
      call FSE_WRITE_SATTR(FID1, -1, "testio_version", "1.0")
C


C     Read the global attribute back out again and save it in the
C     variable "VERSION2", so we can compare the values that we put in
C     and read back out
      call FSE_READ_SATTR(FID1, -1, "testio_version", VERSION2)
C
C     Compare strings
      if (VERSION2 .NE. "1.0") then
         print *, "Failed to read or write global string attribute: ", 
     $        VERSION2, "."
      endif
C
C     Open the second file, which will be completely generated by
C     reading file 1 and rewriting it afterwards into file 2
      call FSE_OPEN(FILENAME2, FID2)
      call FSE_WRITE_SATTR(FID2, -1, "testio_version", VERSION2)
C
      do MODELL = nstart, nend

C     Let's make up some data that we can write into the hdf5 file
 100     format (A,I5)
         print 100, "Calling to read model number ", MODELL
         MTOT = 0.0
         do I = 1, MSL
            MASS(I) = 2.0*I
            MTOT = MTOT + MASS(I)
            R(I) = 3.0*I
            RHO(I) = 4.0*I
            TEMP(I) = 5.0*I
            PR(I) = 6.0*I
            V(I) = 7.0*I
            DCOEFF(I) = 8.0*I
            do J = 1, NSP
               YPS(I,J) = 9.0*I + J
            end do
         end do

C     Write the dataset with the number "MODELL" into the hdf5 file that
C     is associated with "FID1" (FILENAME). Note that you have to pass
C     two variables "M" and "MSL", which may on the first look seem
C     identical. They are not! "M" is the actual number of shells that
C     you have. "MSL" on the other hand is the correct length of the
C     arrays, which you create in the preamble at the beginning. We need
C     this information to access the 2d "YPS" array in our C function,
C     since Fortran 2d arrays are structured differently than C 2d
C     arrays. This function call will save the arrays all at once, not
C     just the first entries.
         call FSE_WRITE_EVOL(FID1, MODELL, M, MSL, MASS, 
     $        R, RHO, TEMP, PR, V, DCOEFF, YPS)
C     Similar to the call of SATTR before. Now we are writing a double
C     attribute that we attach to the curent dataset
C     "MODELL". "total_mass" is the name of the variable, "MTOT" is the
C     value you associate and save. You can save different attributes to
C     the same data set, as long as it does not exist yet. If that is
C     the case, the default is right now to leave the old version in
C     there without overwriting.
         call FSE_WRITE_DATTR(FID1, MODELL, "total_mass", MTOT)
C

C     Read the data set "MODELL" back out of "FID1" and save everything
C     in the "*2" arrays
         call FSE_READ_EVOL(FID1, MODELL, M, MSL, MASS2, 
     $        R2, RHO2, TEMP2, PR2, V2, DCOEFF2, YPS2)

C     Read the double attribute that belongs to "MODELL"
         call FSE_READ_DATTR(FID1, MODELL, "total_mass", MTOT2)
C

C     Check if input and output values are identical
         if (MTOT .ne. MTOT2) then
            exit
         endif
C

C     Write the read out data to "FID2", so we can run h5diff on the two
C     files and make sure that they are identical
         call FSE_WRITE_EVOL(FID2, MODELL, M, MSL, 
     $        MASS2, R2, RHO2, TEMP2, PR2, V2, DCOEFF2, YPS2)
         call FSE_WRITE_DATTR(FID2, MODELL, "total_mass", MTOT2)
      end do
C
C     Close the file ids.
      call FSE_CLOSE(FID1)
      call FSE_CLOSE(FID2)
C
      end
